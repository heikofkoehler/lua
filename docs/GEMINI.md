# Gemini Project Context: Lua VM Implementation

This project is a custom implementation of a Lua-like virtual machine and compiler in C++17. It features a complete pipeline from lexical analysis to bytecode execution, including a stack-based VM with NaN-boxing for efficient value representation.

## Project Overview

- **Language:** C++17
- **Architecture:** Lexer → Parser (Recursive Descent) → AST → Code Generator → Bytecode → Stack-based VM.
- **Value Representation:** NaN-boxing (64-bit values) supporting numbers, booleans, nil, strings, tables, closures, upvalues, and native functions.
- **Key Features:** 
    - Full lexical scoping with closures and upvalues.
    - Table implementation (hash maps) with support for array-style and record-style constructors.
    - Mark-and-sweep garbage collection for all heap-allocated objects.
    - Standard library support for `string`, `table`, and `math` namespaces.
    - Metatables and metamethods (`__index`, `__newindex`, `__add`, etc.).
    - File I/O support.

## Building and Running

### Prerequisites
- CMake 3.10+
- C++17 compatible compiler (GCC, Clang, or MSVC)

### Build Commands
```bash
mkdir -p build
cd build
cmake ..
make
```

### Running the VM
- **Execute a script:** `./lua <path_to_script.lua>`
- **Interactive REPL:** `./lua`
- **Debug Trace:** Build with `cmake -DDEBUG_TRACE_EXECUTION=ON ..` to see VM execution steps.
- **Bytecode Disassembly:** Build with `cmake -DDEBUG_PRINT_CODE=ON ..` to see generated bytecode.

### Testing
A comprehensive test suite is located in the `tests/` directory.
- **Run all tests:** `cd tests && ./run_all_tests.sh ../build/lua`
- Individual tests can be run directly: `../build/lua test_basic.lua`

## Project Structure

- `src/main.cpp`: Entry point, handles REPL and file execution.
- `src/common/`: Shared utilities and common headers.
- `src/compiler/`:
    - `lexer.cpp/hpp`: Tokenizes source code.
    - `parser.cpp/hpp`: Generates AST from tokens.
    - `ast.hpp`: Definition of AST nodes.
    - `codegen.cpp/hpp`: Generates bytecode chunks from AST.
    - `chunk.cpp/hpp`: Bytecode container and constant pool.
- `src/value/`: 
    - `value.hpp/cpp`: NaN-boxed value implementation.
    - `table.hpp`: Hash map implementation.
    - `string.hpp`: Interned string objects.
    - `closure.hpp/upvalue.hpp`: Lexical scoping and closure support.
- `src/vm/`:
    - `vm.cpp/hpp`: Core stack-based virtual machine.
    - `gc.cpp/hpp`: Mark-and-sweep garbage collector.
    - `stdlib_*.cpp`: Standard library implementations (base, math, string, table).
    - `opcode.hpp`: Bytecode instruction definitions.

## Development Conventions

- **Memory Management:** The project uses a custom Mark-and-Sweep Garbage Collector. Heap objects must inherit from `GCObject` and be managed through the VM's object tracking system (`addObject()`).
- **Value Safety:** Avoid raw pointers for Lua values; use the `Value` type which uses indices into VM-managed pools for strings, tables, and closures.
- **Error Handling:** 
    - Use `CompileError` for frontend errors (lexer, parser, codegen).
    - Use `RuntimeError` for VM execution errors.
- **Adding Native Functions:** Native functions follow the signature `bool (*)(VM* vm, int argCount)`. They interact with the VM stack directly and should be registered in the standard library initialization phase.
- **Testing:** Always add a corresponding `.lua` test in `tests/` when implementing new features or fixing bugs.
